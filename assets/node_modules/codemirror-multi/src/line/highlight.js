import { countColumn } from "../util/misc.js"
import { copyState, innerMode, startState } from "../modes.js"
import StringStream from "../util/StringStream.js"

import { getLine, lineNo } from "./utils_line.js"
import { clipPos } from "./pos.js"

class SavedContext {
  constructor(state, lookAhead) {
    this.state = state
    this.lookAhead = lookAhead
  }
}

class Context {
  constructor(doc, state, line, lookAhead) {
    this.state = state
    this.doc = doc
    this.line = line
    this.maxLookAhead = lookAhead || 0
    this.baseTokens = null
    this.baseTokenPos = 1
  }

  lookAhead(n) {
    let line = this.doc.getLine(this.line + n)
    if (line != null && n > this.maxLookAhead) this.maxLookAhead = n
    return line
  }

  baseToken(n) {
    if (!this.baseTokens) return null
    while (this.baseTokens[this.baseTokenPos] <= n)
      this.baseTokenPos += 2
    let type = this.baseTokens[this.baseTokenPos + 1]
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  }

  nextLine() {
    this.line++
    if (this.maxLookAhead > 0) this.maxLookAhead--
  }

  static fromSaved(doc, saved, line) {
    if (saved instanceof SavedContext)
      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead)
    else
      return new Context(doc, copyState(doc.mode, saved), line)
  }

  save(copy) {
    let state = copy !== false ? copyState(this.doc.mode, this.state) : this.state
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  }
}


// Compute a style array (an array starting with a mode generation
// -- for invalidation -- followed by pairs of end positions and
// style strings), which is used to highlight the tokens on the line.
// 计算一个样式数组（一个从模式生成开始的数组——用于失效——后跟一对结束位置和样式字符串），用于高亮显示行上的标记
export function highlightLine(cm, line, context, forceToEnd) {
  // A styles array always starts with a number identifying the
  // mode/overlays that it is based on (for easy invalidation).
  // 一个样式数组总是以一个数字开始，这个数字标识它所基于的模式/覆盖（为了容易失效）。
  var style = []
  var st = [], lineClasses = {};
  // Compute the base array of styles
  // 计算样式的基数组
  for (let i = 0; i < cm.doc.mode.length; i++) {
    st = [cm.state.modeGen]
    runMode(cm, line.text, cm.doc.mode[i], context, i, function (end, style) { return st.push(end, style); }, // 在当前行运行对应mode的解析器，将内容分解成多个token，并获取对应的样式
    lineClasses, forceToEnd);
    style.push(st)
  }
  var state = context.state;

  // Run overlays, adjust style array.
  // 运行覆盖，调整样式数组。
  var loop = function ( o ) {
    context.baseTokens = st;
    var overlay = cm.state.overlays[o], i = 1, at = 0;
    context.state = true;
    runMode(cm, line.text, overlay.mode, context, function (end, style) {
      var start = i;
      // Ensure there's a token end at the current position, and that i points at it
      // 确保在当前位置有一个标记结束，并且我指向它
      while (at < end) {
        var i_end = st[i];
        if (i_end > end)
          { st.splice(i, 1, end, st[i+1], i_end); }
        i += 2;
        at = Math.min(end, i_end);
      }
      if (!style) { return }
      if (overlay.opaque) {
        st.splice(start, i - start, end, "overlay " + style);
        i = start + 2;
      } else {
        for (; start < i; start += 2) {
          var cur = st[start+1];
          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
        }
      }
    }, lineClasses);
    context.state = state;
    context.baseTokens = null;
    context.baseTokenPos = 1;
  };

  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

  return {styles: style, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
}

// 获取每行代码的样式
export function getLineStyles(cm, line, updateFrontier) {
  let oldDemo
  for (let i = 0; i < cm.display.view.length; i++) {
    if (cm.display.view[i].line.text === line.text && i > 0) {
      oldDemo = deep(cm.display.view[i - 1].line.stateAfter)
    }
  }
  if (!line.styles || line.styles[0] != cm.state.modeGen) {
    var context = getContextBefore(cm, lineNo(line)); // 为context赋值
    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state); // 当第一项为假时不必再看第二项
    var result = highlightLine(cm, line, context); // 计算一个样式数组用于高亮显示行上的标记
    if (resetState) {
      context.state = resetState;
    }
    let stateDemo = context.save(!resetState);
    line.stateAfter = deep(stateDemo); // 与mode有关
    for (let i = 0; i < cm.display.view.length; i++) {
      if (cm.display.view[i].line.text === line.text && i > 0) {
        cm.display.view[i - 1].line.stateAfter = deep(oldDemo)
      }
    }
    line.styles = result.styles;
    if (result.classes) {
      line.styleClasses = result.classes;
    } else if (line.styleClasses) {
      line.styleClasses = null;
    }
    if (updateFrontier === cm.doc.highlightFrontier) {
      cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
    }
  }
  return line.styles
}

function deep (obj) {
  var o, i, j
  if (typeof (obj) !== 'object' || obj === null) { return obj }
  if (obj instanceof (Array)) {
    o = []
    i = 0
    j = obj.length
    for (; i < j; i++) {
      if (typeof (obj[i]) === 'object' && obj[i] != null) {
        o[i] = deep(obj[i])
      } else {
        o[i] = obj[i]
      }
    }
  } else {
    o = {}
    for (i in obj) {
      if (typeof (obj[i]) === 'object' && obj[i] != null) {
        o[i] = deep(obj[i])
      } else {
        o[i] = obj[i]
      }
    }
  }
  return o
}

export function getContextBefore(cm, n, precise) { // 获取context，与mode有关
  var doc = cm.doc, display = cm.display;
  // if (!doc.mode.startState) { // 如果doc.mode中不存在startState方法
  //   return new Context(doc, true, n)
  // }
  var start = findStartLine(cm, n, precise); // 查找开始分析的行
  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
  doc.iter(start, n, function (line) {
    processLine(cm, line.text, context);
    var pos = context.line;
    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
    context.nextLine();
  });
  if (precise) { doc.modeFrontier = context.line; }
  return context
}

// Lightweight form of highlight -- proceed over this line and
// update state, but don't save a style array. Used for lines that
// aren't currently visible.
// 高亮显示的轻量级形式——继续这一行并更新状态，但不要保存样式数组。用于当前不可见的行。
export function processLine(cm, text, context, startAt) {
  let mode = cm.doc.mode
  let stream = new StringStream(text, cm.options.tabSize, context)
  stream.start = stream.pos = startAt || 0
  if (text == "") callBlankLine(mode, context.state)
  while (!stream.eol()) {
    for (var i = 0; i < mode.length; i++) {
      readToken(mode[i], stream, context.state[i]);
    }
    stream.start = stream.pos
  }
}

function callBlankLine(mode, state) {
  if (mode.blankLine) return mode.blankLine(state)
  if (!mode.innerMode) return
  let inner = innerMode(mode, state)
  if (inner.mode.blankLine) return inner.mode.blankLine(inner.state)
}

function readToken(mode, stream, state, inner) {
  for (let i = 0; i < 10; i++) {
    if (inner) inner[0] = innerMode(mode, state).mode
    let style = mode.token(stream, state)
    if (stream.pos > stream.start) return style
  }
  throw new Error("Mode " + mode.name + " failed to advance stream.")
}

class Token {
  constructor(stream, type, state) {
    this.start = stream.start; this.end = stream.pos
    this.string = stream.current()
    this.type = type || null
    this.state = state
  }
}

// Utility for getTokenAt and getLineTokens
// getTokenAt和getLineTokens实用程序
export function takeToken(cm, pos, precise, asArray, type) {
  // let oldDemo = deep(cm.display.view[pos.line - 1].line.stateAfter)
  let oldDemo = null
  if (pos.line > 0) {
    if (pos.line - 1 - cm.display.viewFrom > 0 && pos.line - 1 - cm.display.viewFrom < cm.display.view.length) {
      oldDemo = deep(cm.display.view[pos.line - 1 - cm.display.viewFrom].line.stateAfter);
    }
  } else {
    if (pos.line - cm.display.viewFrom > 0 && pos.line - cm.display.viewFrom < cm.display.view.length) {
      oldDemo = deep(cm.display.view[pos.line - cm.display.viewFrom].line.stateAfter);
    }
  }
  var doc = cm.doc, mode = doc.mode, style = [], index;
  pos = clipPos(doc, pos);
  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
  if (asArray) { tokens = []; }
  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
    stream.start = stream.pos;
    for (let i = 0; i < mode.length; i++) {
      if (type && mode[i].name == type) {
        index = i
        style = readToken(mode[i], stream, context.state[i]);
      }
    }
    if (asArray) {
      tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
    }
  }
  // cm.display.view[pos.line - 1].line.stateAfter = deep(oldDemo)
  if (pos.line > 0) {
    if (pos.line - 1 - cm.display.viewFrom > 0 && pos.line - 1 - cm.display.viewFrom < cm.display.view.length) {
      cm.display.view[pos.line - 1 - cm.display.viewFrom].line.stateAfter = deep(oldDemo);
    }
  } else {
    if (pos.line - cm.display.viewFrom > 0 && pos.line - cm.display.viewFrom < cm.display.view.length) {
      cm.display.view[pos.line - cm.display.viewFrom].line.stateAfter = deep(oldDemo);
    }
  }
  return asArray ? tokens : new Token(stream, style, context.state[index])
}

function extractLineClasses(type, output) {
  if (type) for (;;) {
    let lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/)
    if (!lineClass) break
    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)
    let prop = lineClass[1] ? "bgClass" : "textClass"
    if (output[prop] == null)
      output[prop] = lineClass[2]
    else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
      output[prop] += " " + lineClass[2]
  }
  return type
}

// Run the given mode's parser over a line, calling f for each token.
// 在一行上运行对应模式的解析器，为每个token调用方法f。
function runMode(cm, text, mode, context, index, f, lineClasses, forceToEnd) {
  let flattenSpans = mode.flattenSpans
  if (flattenSpans == null) flattenSpans = cm.options.flattenSpans
  let curStart = 0, curStyle = null
  let stream = new StringStream(text, cm.options.tabSize, context), style
  let inner = cm.options.addModeClass && [null]
  if (text == "") extractLineClasses(callBlankLine(mode, context.state[index]), lineClasses)
  while (!stream.eol()) { // this.pos >= this.string.length 返回布尔值
    if (stream.pos > cm.options.maxHighlightLength) {
      flattenSpans = false
      if (forceToEnd) processLine(cm, text, context, stream.pos)
      stream.pos = text.length
      style = null
    } else {
      style = extractLineClasses(readToken(mode, stream, context.state[index], inner), lineClasses)
    }
    if (inner) {
      let mName = inner[0].name
      if (mName) style = "m-" + (style ? mName + " " + style : mName)
    }
    if (!flattenSpans || curStyle != style) {
      while (curStart < stream.start) {
        curStart = Math.min(stream.start, curStart + 5000)
        f(curStart, curStyle)
      }
      curStyle = style
    }
    stream.start = stream.pos
  }
  while (curStart < stream.pos) {
    // Webkit seems to refuse to render text nodes longer than 57444
    // characters, and returns inaccurate measurements in nodes
    // starting around 5000 chars.
    // Webkit似乎拒绝呈现长度超过57444个字符的文本节点，并在大约5000个字符开始的节点中返回不准确的度量值。
    let pos = Math.min(stream.pos, curStart + 5000)
    f(pos, curStyle)
    curStart = pos
  }
}

// Finds the line to start with when starting a parse. Tries to
// find a line with a stateAfter, so that it can start with a
// valid state. If that fails, it returns the line with the
// smallest indentation, which tends to need the least context to
// parse correctly.
function findStartLine(cm, n, precise) {
  let minindent, minline, doc = cm.doc
  let lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)
  for (let search = n; search > lim; --search) {
    if (search <= doc.first) return doc.first
    let line = getLine(doc, search - 1), after = line.stateAfter
    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
      return search
    let indented = countColumn(line.text, null, cm.options.tabSize)
    if (minline == null || minindent > indented) {
      minline = search - 1
      minindent = indented
    }
  }
  return minline
}

export function retreatFrontier(doc, n) {
  doc.modeFrontier = Math.min(doc.modeFrontier, n)
  if (doc.highlightFrontier < n - 10) return
  let start = doc.first
  for (let line = n - 1; line > start; line--) {
    let saved = getLine(doc, line).stateAfter
    // change is on 3
    // state on line 1 looked ahead 2 -- so saw 3
    // test 1 + 2 < 3 should cover this
    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
      start = line + 1
      break
    }
  }
  doc.highlightFrontier = Math.min(doc.highlightFrontier, start)
}
